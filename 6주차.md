# 상대주소지정과 포인터

## 상대주소지정

![상대주소지정](https://upload.wikimedia.org/wikipedia/commons/7/7d/%EC%83%81%EB%8C%80_%EC%A3%BC%EC%86%8C_%EC%A7%80%EC%A0%95_%EB%B0%A9%EC%8B%9D.png)

: 상대 주소 지정은 **기준점(레지스터)**을 기준으로 **상대적인 위치(거리)**를 지정하는 방식

- 기준점인 기저주소는 보통 현재 명령어의 주소 (Program Counter, PC) 또는 기타 레지스터
- 명령어에 있는 값은 기준점에서의 오프셋(offset), 즉 거리
- 프로그램이 로드되는 위치에 따라 실제 주소는 달라지지만, 오프셋은 일정하기 때문에 **위치 독립적 코드(Position Independent Code)**를 작성할 수 있다.
- 프로세스 간 메모리 보호, 모듈화된 코드 작성 등에 유리

## 포인터

![포인터](https://dasima.xyz/wp-content/uploads/2019/02/c-pointer-2-1024x344.png)
: 포인터는 메모리 주소를 값으로 가지는 변수. 다시 말해, 포인터는 어떤 데이터를 저장한 위치를 가리키는 변수

```
int num = 10;
int *p = &num;  // p는 num의 주소를 저장
```

=> "어떤 기준점으로부터 다른 위치를 참조한다"는 공통된 개념 때문에 비슷

# 다차원 배열이 메모리에 저장되는 법

![다차원배열](https://blog.kakaocdn.net/dn/UxV1Z/btqFafL894b/rtlrt89xnBe4HKIEmWzMCK/img.png)

: 다차원 배열도 사실 일차원 배열처럼 연속된 메모리 블록에 저장됨. 2차원, 3차원처럼 보이지만 메모리에는 한 줄로 쭉 이어서 저장

## 예시

```
int arr[2][3] = {
  {1, 2, 3},
  {4, 5, 6}
};
```

실제 메모리 배치?
=> 행 우선으로 메모리에 저장됨 (int 타입이 4비트라고 가정했을 경우)

```

인덱스	값	주소 (예시)
arr[0][0]	1	1000
arr[0][1]	2	1004
arr[0][2]	3	1008
arr[1][0]	4	1012
arr[1][1]	5	1016
arr[1][2]	6	1020
```

주소 계산 방법

```
주소 = base + ((i × 열의 개수) + j) × 자료형 크기
주소 = 1000 + ((1 × 3) + 2) × 4 = 1000 + 20 = 1020
```

> 주소 공간상 열 인덱스가 바뀔 대보다 행 인덱스가 바뀔 때 더 많은 이동이 일어남

```
[ arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2] ]
```

- 열 인덱스(j)만 바뀌는 경우
  arr[0][0] → arr[0][1] → arr[0][2]

메모리 주소: 1000 → 1004 → 1008 (int가 4바이트일 때)

주소 변화량: +4씩

- 행 인덱스(i)만 바뀌는 경우
  arr[0][0] → arr[1][0]

메모리 주소: 1000 → 1012

주소 변화량: +12
→ 한 행의 전체 크기인 3열 × 4바이트 = 12바이트만큼 점프

```
// 행 우선 접근 (더 빠름)
for (int i = 0; i < R; i++) {
  for (int j = 0; j < C; j++) {
    sum += arr[i][j];
  }
}

// 열 우선 접근 (비효율적일 수 있음)
for (int j = 0; j < C; j++) {
  for (int i = 0; i < R; i++) {
    sum += arr[i][j];
  }
}
```

# 배열과 리스트의 차이

![배열과_리스트](https://velog.velcdn.com/images%2Fbky373%2Fpost%2F4b3f8ad2-7d3c-4c44-91c9-e7b456fcb07f%2Fimage.png)

: **배열(array)**과 **리스트(list)**는 모두 데이터를 순서대로 저장하는 자료구조이지만, 내부 동작 방식과 성능, 사용 목적이 다름.

## 배열

: 배열은 동일한 자료형의 원소들을 연속적인 메모리 공간에 저장하는 자료 구조이다. 배열의 크기는 고정되어 있으며, 선언 시에 크기를 지정해야 한다.

![배열](https://laboputer.github.io/assets/img/algorithm/ds/02_array.PNG)

위 그림과 같이 비슷한 특징을 가진 데이터들은 흔히 배열로 저장됨. 이는 컴퓨터 메모리 상에 실제로 순서대로 저장된다.

그래서 우리는 첫번째의 메모리 주소만 알고 있으면 모든 데이터의 값을 바로 접근할 수 있음. [첫번째 주소 + 데이터 타입의 크기 * 인덱스 번호]의 위치에 원하는 데이터가 있기 때문.
즉 검색하는 것은 O(1) 이므로 아주 빠르다.

하지만 배열에 새로운 데이터를 추가하거나 삭제하고 싶은 경우 메모리 상의 주소를 모두 바꾸어야 한다. (최악의 경우) 왜냐하면 배열은 메모리상에 순서대로 저장한 자료구조이기 때문에 데이터가 변경되면 다른 데이터의 물리적 위치도 영향을 받기 때문. 즉 O(N)으로 상대적으로 느린 연산이 된다.

![배열예시](https://laboputer.github.io/assets/img/algorithm/ds/02_array2.PNG)

## 리스트

: 자료구조에서 리스트는 보톤 연결리스트를 의미한다. 리스트는 원소들을 연결하여 저장하는 자료 구조이다. 원소의 개수가 가변적이며, 삽입과 삭제가 자유롭다.

![연결리스트](https://laboputer.github.io/assets/img/algorithm/ds/02_list.PNG)

그림처럼 구조는 약간 다르지만 배열과 똑같이 데이터의 묶음을 저장하는 용도로 리스트를 사용. 하지만 리스트는 배열의 단점이 되었던 추가/삭제 연산 성능을 해결하기 위한 자료구조.

메모리 상의 주소를 순서대로 저장하는 것이 아니라 아무 메모리에나 저장하고 대신에 기존 데이터에 부가 정보로 다음 데이터의 주소를 저장한다. 그렇게 하면 추가/삭제를 해도 전체 데이터 구조가 변하지 않음. 즉 추가/삭제 연산이 O(1)이 된다.

반면에 5번째 데이터를 찾고 싶으면 처음 주소지에서 다음 데이터의 주소를 건너는 연산이 4번 수행되어야 한다. 만약 마지막 데이터를 찾으려면 모든 데이터를 한번씩 봐야 한다. 즉 검색의 연산은 배열보다 느린 O(N)이 됩니다.

![연결리스트2](https://laboputer.github.io/assets/img/algorithm/ds/02_list2.PNG)

# 동적 메모리 할당과 힙 영역

![동적 메모리 할당](https://velog.velcdn.com/images/shinyeongwoon/post/2c9d450d-f95e-41a5-8229-15943e499e64/image.png)

## 정적 메모리 할당

: 프로그램이 컴파일될 때 메모리 크기와 위치가 미리 정해지는 할당 방식

컴파일 타임에 메모리가 확보됨

실행 중에는 크기나 위치를 바꿀 수 없음

## 동적 메모리 할당

: 프로그램 실행 중(runtime)에 메모리 공간을 필요한 만큼 할당받는 것.
일반적인 int a = 5; 같이 **정적 할당(static allocation)**은 컴파일할 때 크기가 정해짐.

반면 동적 할당은 실행 중에 필요에 따라 메모리를 요청하고, 직접 해제도 필요함.

```
int* p = (int*)malloc(sizeof(int) * 10); // int 10개를 위한 메모리 할당, 다 쓰고 나면 반드시 free(p);로 해제
```

## 힙 영역

: 프로그램의 메모리 구조에서 런타임 중 동적으로 할당되는 공간

- 코드(code) 영역
  메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부른다.
  CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

- 데이터(data) 영역
  메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역.
  데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸함.

- 스택(stack) 영역
  메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.
  스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸함.

- 힙(heap) 영역
  메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역.

<!--
# 비트맵

- 간접주소지정

# 3) 동적 메모리 할당 - 힙 영역
배열 등의 변수가 사용하는 메모리는 정적

# 참조와 포인터의 차이
# 블록과 클러스터
- 참조 지역성
-->
