# 4장 컴퓨터 내부 구조

컴퓨터란: 비트를 조작하는 회로로, 다음과 같이 이루어져 있다.

![what's-the-computer](https://velog.velcdn.com/images/fstwon/post/14a8f7d9-b6c9-4047-bae5-c49b84659057/image.png)

1)메모리 : 조작한 비트들을 저장할 장소
2)입출력: 컴퓨터에 정보를 전달하거나 컴퓨터에서 정보를 가져오는 방법
3)CPU : 실제 계산을 처리하는 부품

![program](https://velog.velcdn.com/images/fstwon/post/104c5217-cdb1-4642-be4e-23053142e6dd/image.png)


# ALU Arithmetic Logic Unit 산술 논리 장치

![alu](https://blog.kakaocdn.net/dn/Y7jHY/btrwm96XDT4/8dVm4ophfTHPRG2SrIjog1/img.png)

- 명령코드(opcode): 피연산자에 대해 alu에 어떤 연산자를 적용할지 지정
- 조건코드: 결과에 대한 추가 정보가 들어감(마지막 수행 결과가 음수인지, 마지막 연산 결과가 0인지, 마지막 연산에서 오버플로 혹은 언더플로가 생겼는지)

# Shift Register 
- 데이터를 한 비트씩 왼쪽이나 오른쪽으로 이동(Shift) 시키는 레지스터
- 보통 D 플립플롭(D Flip-Flop) 여러 개를 직렬로 연결
    - D 플립플롭: "클록이 들어오면 입력 D 값을 Q로 출력"해주는 기본적인 메모리 소자
- 매번 클록 신호가 들어올 때마다 데이터가 한 칸씩 이동
![shift-rigister](https://electronicscoach.com/wp-content/uploads/2019/10/shift-register.jpg)

=> 문제점: 1비트씩만 이동 가능하기 때문에 느리다.
=> Barrel shifter가 필요함

# Barrel Shifter
- 단 한 번의 클록 사이클로 원하는 만큼 (예: 5비트) 바로 시프트
- 배럴 시프터는 **멀티플렉서(MUX)**를 활용해서 미리 모든 가능한 시프트 결과를 만들어두고, 원하는 시프트 양을 고르면 바로 그 결과를 선택해줌

![barrel-shift](https://media.licdn.com/dms/image/v2/D5612AQHivVCJVCpLtQ/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1679238936329?e=2147483647&v=beta&t=bdNqb4Bc1EEqIn8gXW0GE3GafsZCaPKU-aCLxbZ46-k)


# 누산기 레지스터를 사용하면 얼마나 간단해질까?

- 누산기(Accumulator)란?
연산을 할 때 중심이 되는 특별한 레지스터. 데이터를 더하거나 빼면 그 결과를 저장하는 공간

예: ADD 100
메모리 주소 100에 있는 값을 가져와서 누산기(= 가산기)에 더하라!
![image](https://github.com/user-attachments/assets/b3ffdbbf-abc5-427d-a1bd-a9eb14c5d029)

실행 과정:
- 명령어 읽기: 명령어 레지스터(IR)가 ADD 100 명령어를 읽음
- 메모리에서 데이터 읽기: 주소 버스를 통해 주소 100의 데이터를 메모리에서 읽어옴
- 누산기와 연산 시작!
: 가산기(= 누산기)에 이미 있는 값과, 메모리에서 가져온 값을 더함 결과를 누산기에 저장
- 연산 결과가 다시 누산기에 저장됨
- 그다음 연산도 여기서 이어감

=> 가산기에서 연산하고, 결과를 가산기에 계속 저장하면서 연산을 이어가는 방식! (계산기처럼)
=> 누산기 이전: 여러 개의 레지스터를 지정해야 함 (복잡)

# 주소 지정 모드(Addressing Mode)

주소지정 방식 비교
✅ 직접 주소지정	메모리 주소를 직접 지정	“바로 저기 100번지 가서 값 가져와”

✅ 간접 주소지정	주소 안에 주소가 있음	“100번지에 가면 또 다른 주소가 적혀 있어. 거기 가서 값 가져와”

✅ 즉시 주소지정	주소가 아니라 값 자체를 사용	“3을 더해! 그냥 지금 당장 3을 써!”


![](https://sdmntprwestus2.oaiusercontent.com/files/00000000-1580-51f8-b887-bf32e724b95a/raw?se=2025-04-03T12%3A59%3A14Z&sp=r&sv=2024-08-04&sr=b&scid=fbc217a4-df4e-5944-a007-b23d3e1fdcba&skoid=b53ae837-f585-4db7-b46f-2d0322fce5a9&sktid=a48cca56-e6da-484e-a814-9c849652bcb3&skt=2025-04-02T21%3A53%3A56Z&ske=2025-04-03T21%3A53%3A56Z&sks=b&skv=2024-08-04&sig=JTzigcBEZJm5ldCgftTwYQLzBQd6Fm1orNNaOL5NzkM%3D)


#  컴퓨터 내부에서 명령어를 실행하기 위한 데이터 흐름과 제어 신호
![Screenshot 2025-04-03 at 9 03 17 PM](https://github.com/user-attachments/assets/c6fd0ac7-3ae6-4c40-975e-e36dd9c9a579)

1. 명령어를 가져오기 (Fetch): 프로그램 카운터는 다음에 실행할 명령어의 주소를 가지고 있음
이 주소를 주소 버스를 통해 메모리로 보내면, 메모리는 해당 주소에 있는 명령어를 데이터 버스를 통해 명령어 레지스터로 전달해줌

2. 명령어 해석하기 (Decode): 명령어 레지스터에 들어온 명령어는 어떤 동작을 해야 하는지(opcode), 어떤 데이터를 사용할지 등을 알려줌
이 정보는 ALU(산술 논리 장치)와 다른 레지스터들에 전달됨

3. 명령어 실행하기 (Execute): ALU는 실제 계산을 수행하는 장치.
ALU는 피연산자 A, B를 받아서 결과를 만들고, 그 결과를 누산기나 다른 레지스터로 보낼 수 있음.
조건 판단이 필요한 명령어라면, 조건 코드 레지스터가 그 결과를 저장.

4. 결과 저장하거나 다음 명령어로 이동: 연산 결과는 **누산기(ACC)**에 저장되거나, 메모리에 다시 저장됨.

그런 다음, 다시 프로그램 카운터가 증가하면서 다음 명령어를 가져오는 과정이 반복



# 5장 컴퓨터 아키텍처와 운영체제

## 1) CPU의 정의
- 과거의 CPU: 중앙 처리 장치(Central Processing Unit)로서 컴퓨터에서 유일한 연산 장치
하나의 CPU가 하나의 명령어 흐름(즉, 하나의 프로그램 실행 흐름)을 처리했음. 모든 계산, 논리 연산, 제어 흐름 등을 하나의 **연산 장치(코어)**가 맡았음.

- 프로세서 코어: 코어 한 개를 말함
** 코어(Core)? 실제로 명령어를 해석하고 실행하는 물리적 장치
- 하나의 CPU 안에 들어 있는 작은 CPU처럼 동작하는 단위
- 하나의 코어는 독립적으로 연산하고 명령을 실행할 수 있음

- 멀티코어: 하나의 CPU 안에 여러 개의 코어가 들어 있는 구조
예: 4코어 CPU는 동시에 4개의 명령 흐름을 병렬로 처리 가능

코어 수가 많아질수록 동시에 더 많은 작업을 처리 가능


✅ 그래서, 요즘의 CPU 정의는?
예전에는 "CPU = 하나의 코어"였다면, 지금은 "CPU = 여러 개의 코어가 들어 있는 패키지"

우리가 흔히 CPU라고 부르는 Intel i7, AMD Ryzen 이런 것들은
내부적으로는 4, 6, 8, 심지어 64코어까지 들어 있는 구조.

따라서 지금은 CPU를 "코어들을 묶은 하나의 연산 시스템"으로 보는 게 맞음.

![core](https://blog.kakaocdn.net/dn/bREFrl/btr8tuFBXtR/VVKruqgdkklsmyaqKs45R0/img.jpg)


# 2) 함수가 호출되는 과정


```
function
cube(x)
{
    return (x*x*x)
}

y = cube(3)
```


- cube 함수 호출
- 인자로 3을 전달
- 함수 실행 후 다시 명령어 105번으로 복귀 

100   pca                 ; 현재 명령어 주소(100)를 누산기에 저장  
                          ; → 복귀 주소 계산을 위한 시작

101   add 5(즉시)         ; 누산기 값에 5를 더함 → 100 + 5 = 105  
                          ; → 함수에서 돌아올 위치인 105 주소 계산

102   store 200(간접)     ; 계산한 복귀 주소(105)를 주소 200번에 저장  
                          ; → 나중에 함수에서 돌아올 때 사용할 주소

103   load 3(즉시)        ; cube 함수의 인자 값인 3을 누산기에 넣음  
                          ; → 인자를 함수에 전달

104   bra 300(직접)       ; 주소 300에 있는 cube 함수로 점프 (함수 호출)  
                          ; → cube 함수 실행 시작

300 번에서 cube함수 시작되고, 함수가 다 끝나면 저장해두었던 200번 주소를 보고 그 안에 있던 105번 주소로 다시 돌아오는 구조

![Screenshot 2025-04-03 at 9 25 37 PM](https://github.com/user-attachments/assets/afa4acdb-d8e6-450b-8094-ab5a9af9cc53)


# 3) JPEG 압축을 이용해 사진 크기를 감소시키는 법

JPEG 압축: 큰 그림 파일을 눈에 안 띄게 살짝 흐릿하게 만들어서 용량을 확 줄이는 기술


- 1단계: 색을 줄임 (Color 변환)
원래 사진은 빨강(R), 초록(G), 파랑(B)으로 되어 있는데 JPEG은 이걸 밝기(Y) + **색 정보(Cb, Cr)**로 바꿈. (사람 눈은 모름)
- 2단계: 8X8 블록 픽셀 덩어리로 나눔

전체 이미지를 한꺼번에 처리하면 계산이 너무 복잡하기 때문에, 8×8 블록으로 자르면 작은 단위로 계산 가능해서 압축, 처리, 복원이 용이함.

JPEG에서는 이 블록 하나하나에 DCT(이산 코사인 변환)을 적용한다.

- 3단계: DCT 적용

사진의 밝기·색 변화 정도를 숫자로 변환하는 과정


```
def split_into_blocks(image, block_size=8):
    blocks = []
    height, width = image.shape  # 예: 240 x 320

    for y in range(0, height, block_size):
        for x in range(0, width, block_size):
            #  8×8 블록 하나를 자르는 부분
            block = image[y:y+block_size, x:x+block_size]
            blocks.append(block)

    return blocks

```

- 4단계: 양자화, 사용하지 않은 숫자 0에 가깝게 줄임
- 5단계: 남은 숫자 허프만 부화화를 통해 더 압축
