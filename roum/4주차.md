# 4장 컴퓨터 내부 구조

컴퓨터란: 비트를 조작하는 회로로, 다음과 같이 이루어져 있다.

![what's-the-computer](https://velog.velcdn.com/images/fstwon/post/14a8f7d9-b6c9-4047-bae5-c49b84659057/image.png)

1)메모리 : 조작한 비트들을 저장할 장소
2)입출력: 컴퓨터에 정보를 전달하거나 컴퓨터에서 정보를 가져오는 방법
3)CPU : 실제 계산을 처리하는 부품

![program](https://velog.velcdn.com/images/fstwon/post/104c5217-cdb1-4642-be4e-23053142e6dd/image.png)


# ALU Arithmetic Logic Unit 산술 논리 장치

![alu](https://blog.kakaocdn.net/dn/Y7jHY/btrwm96XDT4/8dVm4ophfTHPRG2SrIjog1/img.png)

- 명령코드(opcode): 피연산자에 대해 alu에 어떤 연산자를 적용할지 지정
- 조건코드: 결과에 대한 추가 정보가 들어감(마지막 수행 결과가 음수인지, 마지막 연산 결과가 0인지, 마지막 연산에서 오버플로 혹은 언더플로가 생겼는지)

# Shift Register 
- 데이터를 한 비트씩 왼쪽이나 오른쪽으로 이동(Shift) 시키는 레지스터
- 보통 D 플립플롭(D Flip-Flop) 여러 개를 직렬로 연결
    - D 플립플롭: "클록이 들어오면 입력 D 값을 Q로 출력"해주는 기본적인 메모리 소자
- 매번 클록 신호가 들어올 때마다 데이터가 한 칸씩 이동
![shift-rigister](https://electronicscoach.com/wp-content/uploads/2019/10/shift-register.jpg)

=> 문제점: 1비트씩만 이동 가능하기 때문에 느리다.
=> Barrel shifter가 필요함

# Barrel Shifter
- 단 한 번의 클록 사이클로 원하는 만큼 (예: 5비트) 바로 시프트
- 배럴 시프터는 **멀티플렉서(MUX)**를 활용해서 미리 모든 가능한 시프트 결과를 만들어두고, 원하는 시프트 양을 고르면 바로 그 결과를 선택해줌

![barrel-shift](https://media.licdn.com/dms/image/v2/D5612AQHivVCJVCpLtQ/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1679238936329?e=2147483647&v=beta&t=bdNqb4Bc1EEqIn8gXW0GE3GafsZCaPKU-aCLxbZ46-k)


# 누산기 레지스터를 사용하면 얼마나 간단해질까?

- 누산기(Accumulator)란?
연산을 할 때 중심이 되는 특별한 레지스터. 데이터를 더하거나 빼면 그 결과를 저장하는 공간

예: ADD 100
메모리 주소 100에 있는 값을 가져와서 누산기(= 가산기)에 더하라!
![image](https://github.com/user-attachments/assets/b3ffdbbf-abc5-427d-a1bd-a9eb14c5d029)

실행 과정:
- 명령어 읽기: 명령어 레지스터(IR)가 ADD 100 명령어를 읽음
- 메모리에서 데이터 읽기: 주소 버스를 통해 주소 100의 데이터를 메모리에서 읽어옴
- 누산기와 연산 시작!
: 가산기(= 누산기)에 이미 있는 값과, 메모리에서 가져온 값을 더함 결과를 누산기에 저장
- 연산 결과가 다시 누산기에 저장됨
- 그다음 연산도 여기서 이어감

=> 가산기에서 연산하고, 결과를 가산기에 계속 저장하면서 연산을 이어가는 방식! (계산기처럼)
=> 누산기 이전: 여러 개의 레지스터를 지정해야 함 (복잡)

# 주소 지정 모드(Addressing Mode)

주소지정 방식 비교
✅ 직접 주소지정	메모리 주소를 직접 지정	“바로 저기 100번지 가서 값 가져와”

✅ 간접 주소지정	주소 안에 주소가 있음	“100번지에 가면 또 다른 주소가 적혀 있어. 거기 가서 값 가져와”

✅ 즉시 주소지정	주소가 아니라 값 자체를 사용	“3을 더해! 그냥 지금 당장 3을 써!”


![](https://sdmntprwestus2.oaiusercontent.com/files/00000000-1580-51f8-b887-bf32e724b95a/raw?se=2025-04-03T12%3A59%3A14Z&sp=r&sv=2024-08-04&sr=b&scid=fbc217a4-df4e-5944-a007-b23d3e1fdcba&skoid=b53ae837-f585-4db7-b46f-2d0322fce5a9&sktid=a48cca56-e6da-484e-a814-9c849652bcb3&skt=2025-04-02T21%3A53%3A56Z&ske=2025-04-03T21%3A53%3A56Z&sks=b&skv=2024-08-04&sig=JTzigcBEZJm5ldCgftTwYQLzBQd6Fm1orNNaOL5NzkM%3D)


#  컴퓨터 내부에서 명령어를 실행하기 위한 데이터 흐름과 제어 신호
![Screenshot 2025-04-03 at 9 03 17 PM](https://github.com/user-attachments/assets/c6fd0ac7-3ae6-4c40-975e-e36dd9c9a579)

1. 명령어를 가져오기 (Fetch): 프로그램 카운터는 다음에 실행할 명령어의 주소를 가지고 있음
이 주소를 주소 버스를 통해 메모리로 보내면, 메모리는 해당 주소에 있는 명령어를 데이터 버스를 통해 명령어 레지스터로 전달해줌

2. 명령어 해석하기 (Decode): 명령어 레지스터에 들어온 명령어는 어떤 동작을 해야 하는지(opcode), 어떤 데이터를 사용할지 등을 알려줌
이 정보는 ALU(산술 논리 장치)와 다른 레지스터들에 전달됨

3. 명령어 실행하기 (Execute): ALU는 실제 계산을 수행하는 장치.
ALU는 피연산자 A, B를 받아서 결과를 만들고, 그 결과를 누산기나 다른 레지스터로 보낼 수 있음.
조건 판단이 필요한 명령어라면, 조건 코드 레지스터가 그 결과를 저장.

4. 결과 저장하거나 다음 명령어로 이동: 연산 결과는 **누산기(ACC)**에 저장되거나, 메모리에 다시 저장됨.

그런 다음, 다시 프로그램 카운터가 증가하면서 다음 명령어를 가져오는 과정이 반복



